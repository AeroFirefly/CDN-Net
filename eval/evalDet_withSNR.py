import math
import os

import pandas as pd
from scipy.spatial import KDTree
import numpy as np
import matplotlib.pyplot as plt
plt.rcParams['font.family'] = 'serif'
plt.rcParams["font.family"] = ["Times New Roman"] + plt.rcParams['font.serif']

def evalWithSNR(gt_ipd_dir, test_ipd_dir, bins_label, isSex=False):
    """
    Evaluate detection metrics with different SNR targets.

    Parameters:
        gt_ipd_dir : ground-truth label file 
        test_ipd_dir : prediction result file
        bins_label : partition method for SNR bins
        isSex : if prediction is generated by SExtractor

    Returns:
        tp_count_array : true-positive number, organized by bins_label
        fn_count_array : false-negative number, organized by bins_label
    """
    bins_len = len(bins_label)   # 0, 3, 10, 100

    count = 0
    pre_sum = 0
    rec_sum = 0
    f1_sum = 0
    fa_sum = 0
    tp_count_array = np.zeros(bins_len)
    fn_count_array = np.zeros(bins_len)
    for filename in os.listdir(test_ipd_dir):
        # pred
        pred_ipd = os.path.join(test_ipd_dir, filename)
        if os.path.isdir(pred_ipd): continue
        if not isSex:
            df_pred = pd.read_table(pred_ipd, sep='\s+', header=None, encoding='utf-8',
                                    names=['col', 'row', 'pixnum', 'length', 'width', 'graysum', 'bgavg', 'bgvar'])
        else:
            pred_cat = pred_ipd
            df_pred = pd.read_table(pred_cat, sep='\s+', header=None, skiprows=17, encoding='utf-8',
                                    names=['NUMBER', 'X_IMAGE', 'Y_IMAGE', 'XWIN_IMAGE', 'YWIN_IMAGE', 'col', 'row', 'MAG_AUTO',
                                           'MAG_MODEL', 'FWHM_IMAGE', 'FLUX_RADIUS', 'FLAGS', 'FLAGS_WIN', 'NITER_WIN',
                                           'SPREAD_MODEL', 'SPREADERR_MODEL', 'ID_PARENT'])

        # gt
        gt_ipd_path = os.path.join(gt_ipd_dir, filename if not isSex else filename.replace('cat', 'IPD'))
        df_gt = pd.read_table(gt_ipd_path, sep='\s+', header=None, encoding='utf-8',
                              names=['col', 'row', 'pixnum', 'length', 'width', 'graysum', 'bgavg', 'bgvar', 'snr'])

        # calculate tp, fp, fn
        thres = 1.5
        all_pred = len(df_pred)
        all_gt = len(df_gt)

        ''' evaluate by KD-Tree '''
        kd_gt = KDTree(df_gt[['col', 'row']].values)
        match = kd_gt.query(df_pred[['col', 'row']].values, k=1)
        tp_idx_fromgt = np.unique(match[1][match[0] < thres])
        tp_objs = df_gt.copy().iloc[tp_idx_fromgt]
        fn_objs = df_gt.copy().drop(labels=tp_idx_fromgt)
        # static snr
        for _, tp_item in tp_objs.iterrows():
            snr_item = tp_item['snr']
            if snr_item < 0:
                pass
            elif snr_item >= bins_label[-1]:
                tp_count_array[-1] += 1
            else:
                for snr_i in range(bins_len-1):
                    if bins_label[snr_i] <= snr_item < bins_label[snr_i+1]:
                        tp_count_array[snr_i] += 1
                        break
        for _, fn_item in fn_objs.iterrows():
            snr_item = fn_item['snr']
            if snr_item < 0:
                pass
            elif snr_item >= bins_label[-1]:
                fn_count_array[-1] += 1
            else:
                for snr_i in range(bins_len - 1):
                    if bins_label[snr_i] <= snr_item < bins_label[snr_i + 1]:
                        fn_count_array[snr_i] += 1
                        break

        tp = len(np.unique(match[1][match[0] < thres]))
        fp = all_pred - tp
        fn = all_gt - tp
        if tp + fp == 0:
            precision = 0
        else:
            precision = tp / (tp + fp)
        recall = tp / (tp + fn)
        if precision != 0 and recall != 0:
            f1 = 2 * precision * recall / (precision + recall)
            faRate = (1 / precision - 1) * recall
        else:
            f1 = 0
            faRate = 0
        count += 1
        pre_sum += precision
        rec_sum += recall
        f1_sum += f1
        fa_sum += faRate
    precision = pre_sum / count
    recall = rec_sum / count
    f1 = f1_sum / count
    faRate = fa_sum / count
    print('precision:{} recall:{} f1:{} falseAlarm:{}'.format(precision, recall, f1, faRate))
    return tp_count_array, fn_count_array


if __name__ == '__main__':
    '''
    Evaluate detection metrics with different SNR targets. 
    Both simu-data and real-data.
    '''

    # ''' real-data settings'''
    gt_dir = os.path.join('../dataset/fits_softCircle_modified/ipdSNR')
    test_file_dir_SE = os.path.join('/home/lixy/workspace/tzb2/CenterNet-BYSJ/eval/outipd/_se')
    test_file_dir_Unet = os.path.join('/home/lixy/workspace/tzb2/CenterNet-BYSJ/eval/outipd/_unet')
    test_file_dir_HiA = os.path.join('/home/lixy/workspace/tzb2/HASDet_BYSJ/outfiles/LXY_lab2_model_shallow_IPD_2')
    bins_label = [0, 3, 5, 10]
    bins = len(bins_label)
    save_dir = os.path.join('../outfiles/DetMetricSNR/tp_fp_SNR_real_shallow.png')

    tp_se, fn_se = evalWithSNR(gt_dir, test_file_dir_SE, bins_label)    # for real-data
    tp_unet, fn_unet = evalWithSNR(gt_dir, test_file_dir_Unet, bins_label)
    tp_hia, fn_hia = evalWithSNR(gt_dir, test_file_dir_HiA, bins_label)

    # plot tp snr hist
    plt.figure()
    bar_w = 0.3
    bias_range = 1.2
    bar_st_scale = 1.4
    bar_margin = np.arange(0,bias_range,bias_range/3)-np.arange(0,bias_range,bias_range/3).mean()
    p_tp = plt.bar(np.arange(bins)*bar_st_scale+bar_margin[0], tp_se, bar_w, color='teal', label='SExtractor')  # or plt.hist
    p_fn = plt.bar(np.arange(bins)*bar_st_scale+bar_margin[0], fn_se, bar_w, bottom=tp_se, color='teal', alpha=0.5)
    plt.bar_label(p_tp, label_type='center')
    plt.bar_label(p_fn, label_type='center')

    p_tp = plt.bar(np.arange(bins) * bar_st_scale + bar_margin[1], tp_unet, bar_w, color='plum', label='StarNet*')  # or plt.hist
    p_fn = plt.bar(np.arange(bins) * bar_st_scale + bar_margin[1], fn_unet, bar_w, bottom=tp_unet, color='plum', alpha=0.5)
    plt.bar_label(p_tp, label_type='center')
    plt.bar_label(p_fn, label_type='center')

    p_tp = plt.bar(np.arange(bins)*bar_st_scale+bar_margin[2], tp_hia, bar_w, color='orchid', label='CDN-Net')  # or plt.hist
    p_fn = plt.bar(np.arange(bins)*bar_st_scale+bar_margin[2], fn_hia, bar_w, bottom=tp_hia, color='orchid', alpha=0.5)
    plt.bar_label(p_tp, label_type='center')
    plt.bar_label(p_fn, label_type='center')
    tags = []
    for i in range(bins-1):
        tags.append('{}-{}'.format(bins_label[i], bins_label[i+1]))
    tags.append('{}+'.format(bins_label[-1]))
    plt.xticks(np.arange(bins)*bar_st_scale, tags, rotation=-45)
    plt.xlabel('SNR', fontsize=12)
    plt.ylabel('detection amount', fontsize=12)
    plt.legend(loc='upper right')

    ax = plt.gca()
    # set aspect ratio to 1
    ratio = 0.618
    x_left, x_right = ax.get_xlim()
    y_low, y_high = ax.get_ylim()
    ax.set_aspect(abs((x_right - x_left) / (y_low - y_high)) * ratio)

    plt.savefig(save_dir, bbox_inches='tight', pad_inches=0.1)
    # plt.show()
